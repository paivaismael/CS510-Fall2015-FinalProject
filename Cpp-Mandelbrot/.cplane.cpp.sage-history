"// Pre-processor directives to prevent redundant library loading\n#ifndef __CPLANE_CPP\n#define __CPLANE_CPP\n\n// Includes the header declarations of important libraries\n#include <boost/numeric/ublas/matrix.hpp>\n#include <boost/numeric/ublas/io.hpp>\n#include \"cplane.h\"\n\n// Uses namespace to simplify the writing of the code\nusing namespace std;\nusing namespace boost::numeric::ublas;\n\n// Sets an appropriated cplane\nvoid set(cplane &cp, const VALUE xmin, const VALUE xmax, const VALUE ymin, const VALUE ymax){\n  const VALUE xstep = (xmax - xmin)/(cp.cols - 1);\n  const VALUE ystep = (ymax - ymin)/(cp.rows - 1);\n  INT i, j;\n  COMPLEX z;\n  for (i=0; i<cp.rows; i++){\n    for (j=0; j<cp.cols; j++){\n        real(z) = xmin + j * xstep;\n        imag(z) = imag(z)=ymin + i * ystep;\n        cp.mat(i,j) = z;\n    }\n  }\n}\n\n// Verifies if the values received are adequated and, if that is the case, allocates space and calls the function set\ncplane constructor(const VALUE xmin, const VALUE xmax, const VALUE ymin, const VALUE ymax, const INT xpoints, const INT ypoints){\n  cplane c;\n  c.rows = ypoints;\n  c.cols = xpoints;\n  if (xpoints < 2 || ypoints < 2) {\n    cout << \"ERROR: xpoints and ypoints should be at least equal to 2\" << endl;\n  }\n  else if (xmin >= xmax){\n    cout << \"ERROR: xmax has to be greater than xmin\" << endl;\n  }\n  else if (ymin >= ymax){\n    cout << \"ERROR: ymax has to be greater than ymin\" << endl;\n  }\n  else{\n    c.mat.resize(c.rows, c.cols);\n    set(c, xmin, xmax, ymin, ymax);\n  }\n  return c;\n}\n\n// Prints a cplane (It is a helper to test this library)\nvoid print_cplane(cplane &cp){\n  INT i, j;\n  cout << \"Cplane (rows: \" << cp.rows << \", cols: \" << cp.cols << \")\" << endl;\n  for(i=0; i<cp.rows; i++) {\n    for(j=0; j<cp.cols; j++) {\n     cout << cp.mat(i,j) << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n#endif\n"
{"patch":[[[[0,"\n// "],[-1,"I"],[1,"i"],[0,"nclude"],[-1,"s"],[0," the"]],107,107,16,15],[[[0,"ions"],[-1," of important libraries"],[0,"\n#in"]],138,138,31,8],[[[0,"h\"\n\n"],[-1,"// Uses namespace to simplify the writing of the code\n"],[0,"usin"]],240,240,62,8],[[[0,"s;\n\n"],[-1,"// Sets an appropriated cplane\n"],[0,"void"]],301,301,39,8],[[[0,"\n}\n\n"],[-1,"// Verifies if the values received are adequated and, if that is the case, allocates space and calls the function set\n"],[0,"cpla"]],700,700,126,8],[[[0,"points;\n"],[1,"  c.mat.resize(c.rows, c.cols);\n"],[0,"  if (xp"]],878,878,16,48],[[[0,"se{\n"],[-1,"    c.mat.resize(c.rows, c.cols);\n"],[0,"    "]],1228,1228,42,8],[[[0,"\n}\n\n"],[-1,"// Prints a cplane (It is a helper to test this library)\n"],[0,"void"]],1283,1283,65,8]],"time":1450134755502}
{"patch":[[[[0,"ude "],[-1,"<boost/numeric/ublas/matrix.hpp>"],[1,"\"cplane.h\""],[0,"\n#in"]],148,148,40,18],[[[0,"/io.hpp>"],[-1,"\n#include \"cplane.h\""],[0,"\n\nusing "]],192,192,36,16],[[[0,"rows; i++){\n"],[1,"    matrix_row<matrix<COMPLEX> > row(cp.mat, i);\n"],[0,"    for (j=0"]],501,501,24,73],[[[0,"mag(z) ="],[1,"  ymin + i * ystep;\n        row(j)=z;\n    }\n  }\n}\n\n/*void set(cplane &cp, const VALUE xmin, const VALUE xmax, const VALUE ymin, const VALUE ymax){\n  const VALUE xstep = (xmax - xmin)/(cp.cols - 1);\n  const VALUE ystep = (ymax - ymin)/(cp.rows - 1);\n  INT i, j;\n  COMPLEX z;\n  for (i=0; i<cp.rows; i++){\n    for (j=0; j<cp.cols; j++){\n//        cp.mat.resize(i,j);\n        real(z)=xmin + j * xstep;\n       "],[0," imag(z)"]],638,638,16,421],[[[0,"      cp.mat"],[1," "],[0,"(i,j) = z;\n "]],1080,1080,24,25],[[[0," }\n  }\n}"],[1,"*/"],[0,"\n\ncplane"]],1107,1107,16,18],[[[0,"\n  c.mat"],[-1,".resize"],[1," "],[0,"(c.rows,"]],1300,1300,23,17],[[[0,"  else{\n"],[1,"    c.rows = ypoints;\n    c.cols = xpoints;\n    c.mat (c.rows,c.cols);\n"],[0,"    set("]],1633,1633,16,87],[[[0,"ols; j++) {\n"],[1,"      cp.mat.resize(i+1,j+1);\n "],[0,"     cout <<"]],1937,1937,24,55]],"time":1449176419244}
{"patch":[[[[0,"e.h\""],[-1,"\n#include <boost/numeric/ublas/io.hpp>"],[0,"\n\nus"]],158,158,46,8],[[[0,"    "],[-1,"matrix_row<matrix<COMPLEX> > row(cp.mat, i);\n    for (j=0; j<cp.cols; j++){\n        real(z) = xmin + j * xstep;\n        imag(z) =  ymin + i * ystep;\n        row(j)=z;\n    }\n  }\n}\n\n/*void set(cplane &cp, const VALUE xmin, const VALUE xmax, const VALUE ymin, const VALUE ymax){\n  const VALUE xstep = (xmax - xmin)/(cp.cols - 1);\n  const VALUE ystep = (ymax - ymin)/(cp.rows - 1);\n  INT i, j;\n  COMPLEX z;\n  for (i=0; i<cp.rows; i++){\n    for (j=0; j<cp.cols; j++){\n//"],[1,"for (j=0; j<cp.cols; j++){\n"],[0,"    "]],475,475,473,35],[[[0,"  cp.mat"],[-1," "],[0,""],[1,""],[0,"(i,j) = "]],608,608,17,16],[[[0," }\n}"],[-1,"*/"],[0,""],[1,""],[0,"\n\ncp"]],634,634,10,8]],"time":1449097788276}
{"patch":[[[[0,"ude "],[-1,"\"cplane.h\""],[1,"<complex>"],[0,"\n\nus"]],148,148,18,17]],"time":1449090653976}
{"patch":[[[[0,"ude "],[-1,"<complex>"],[1,"\"cplane.h\""],[0,"\n\nus"]],148,148,17,18]],"time":1449090647585}